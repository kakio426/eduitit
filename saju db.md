결정론적 사주 명리 해석 시스템: 데이터 아키텍처 및 알고리즘 로직에 관한 심층 기술 보고서1. 서론: 확률적 AI와 결정론적 운명학의 통합 과제대규모 언어 모델(LLM)을 활용한 사주(Saju, Four Pillars of Destiny) 서비스 구축의 핵심 난제는 생성형 AI의 본질적인 확률적 특성과 사주 명리학의 결정론적 규칙 사이의 불일치에서 발생합니다. 사주 명리는 사용자의 생년월일시라는 입력값이 주어지면, 만세력(Ten Thousand Year Calendar)에 의거하여 간지(干支)가 고정적으로 도출되어야 하며, 오행(Five Elements)의 생극제화(生剋制化) 원리에 따라 해석의 골자가 수학적으로 결정되는 시스템입니다. 그러나 LLM은 토큰 예측 확률에 기반하므로, 동일한 입력값에 대해서도 매번 다른 해석을 내놓거나, 심지어는 명리학적 규칙을 위배하는 '환각(Hallucination)'을 일으킬 위험이 있습니다.사용자의 신뢰를 확보하기 위해서는 답변의 일관성(Consistency)이 필수적입니다. 이를 달성하기 위해서는 AI 모델의 내부 지식에 의존하는 것이 아니라, 외부의 견고한 데이터베이스(DB)와 알고리즘 엔진을 통해 계산된 '단일 진실 공급원(Single Source of Truth, SSOT)'을 구축하고, LLM은 오직 이 데이터를 자연어로 변환하는 인터페이스 역할만 수행하도록 아키텍처를 설계해야 합니다.본 보고서는 이러한 시스템을 구축하기 위해 필요한 정밀 만세력 알고리즘, 정규화된 데이터베이스 스키마 설계, 명리 해석의 논리적 충돌 해결을 위한 알고리즘, 그리고 답변의 일관성을 강제하기 위한 프롬프트 엔지니어링 및 JSON 스키마 전략을 포괄적으로 다룹니다.2. 천문 알고리즘과 만세력 엔진: 시공간의 정밀 데이터화사주 분석의 정확도는 입력된 그레고리력 시간을 사주 팔자의 간지 체계로 변환하는 만세력 엔진의 정밀도에 전적으로 의존합니다. 이 과정에서 발생하는 1분의 오차는 시주(時柱)를 바꾸고, 하루의 오차는 일주(日柱) 전체를 뒤바꿔 해석의 근간을 흔들 수 있습니다. 따라서 DB 구축의 첫 단계는 천문학적 데이터를 처리하는 고정밀 연산 레이어의 확보입니다.2.1. 태양시 보정과 균시차(Equation of Time) 적용사주 명리학에서 사용하는 시간은 표준시(Standard Time)가 아닌 진태양시(True Solar Time)입니다. 표준시는 행정적 편의를 위해 설정된 평균 태양시이므로, 사주를 정확히 산출하기 위해서는 두 가지 핵심 보정 절차가 데이터베이스 로직에 포함되어야 합니다.경도에 따른 시차 보정 (Longitude Correction): 한국 표준시(KST)는 동경 135도를 기준으로 하지만, 서울은 동경 127도에 위치합니다. 이로 인해 약 32분의 시차가 발생합니다. DB의 UserProfile 테이블은 사용자의 출생 도시 정보를 저장해야 하며, 백엔드 로직은 해당 도시의 위도/경도 좌표를 astral이나 pyswisseph와 같은 라이브러리를 통해 조회하여 정확한 태양 남중 시각을 계산해야 합니다. 예를 들어, 서울에서 13:30에 태어난 사람은 표준시로는 미(未)시(13:00~15:00)에 해당할 수 있으나, 경도 보정을 거치면 오(午)시(11:30~13:30)로 판별될 수 있습니다. 이러한 경계값 처리는 AI가 아닌 결정론적 알고리즘이 담당해야 합니다.균시차(Equation of Time) 보정: 지구의 공전 궤도가 타원형이고 자전축이 기울어져 있어 발생하는 태양의 겉보기 속도 차이입니다. 계절에 따라 최대 +16분에서 -14분까지 차이가 발생합니다. 정밀한 사주 DB 시스템은 날짜별 균시차 값을 룩업 테이블(Lookup Table)로 보유하거나, 실시간 천문 연산 라이브러리를 통해 이 값을 반영하여 시주(Hour Pillar)의 경계선을 확정해야 합니다.2.2. 24절기와 월주(Month Pillar)의 확정 로직사주에서 월(Month)의 구분은 달력상의 1일이 아니라, 태양이 황도상의 특정 지점(입춘 315도, 경칩 345도 등)을 통과하는 절기(Solar Terms) 입입 시각을 기준으로 합니다.입춘(Lichun)과 연주(Year Pillar)의 교체: 한 해의 시작은 양력 1월 1일도, 음력 설날도 아닌 입춘 시각입니다. DB에는 1900년부터 2100년까지(혹은 그 이상)의 모든 절기 입입 시각이 '분' 단위까지 정확하게 저장되어야 합니다.윤달(Leap Month) 처리: 음력 윤달에 태어난 사용자의 경우, 사주 명리학에서는 별도의 윤달 간지를 쓰지 않고 해당 절기에 귀속시킵니다. 그러나 사용자가 입력하는 "윤달 생일"을 정확한 태양력 날짜로 변환하기 위해 korean-lunar-calendar와 같은 특화된 라이브러리 연동이 필수적입니다. 중국식 음력과 한국식 음력은 계산 기준(자오선)의 차이로 인해 설날이나 윤달의 배치가 달라질 수 있으므로, 반드시 한국천문연구원(KARI) 데이터를 기반으로 하는 라이브러리를 채택해야 데이터 무결성이 보장됩니다.2.3. 시주 산출 알고리즘: 오서둔(Five Rats Chasing Hour)시주(Hour Pillar)는 일주(Day Pillar)의 천간(Heavenly Stem)에 종속되어 결정됩니다. 이를 '오서둔(五鼠遁, Five Rats Chasing Hour)'법이라 하며, 이 규칙은 예외가 없는 강한 논리적 제약 조건입니다. DB 구축 시 이 로직은 하드코딩되거나 참조 테이블로 구현되어야 하며, AI가 임의로 생성해서는 안 됩니다.[표 1] 오서둔(五鼠遁) 시두법 로직 테이블일간(Day Stem)자시(23~01)축시(01~03)인시(03~05)묘시(05~07)진시(07~09)사시(09~11)...갑(甲), 기(己)갑자(甲子)을축(乙丑)병인(丙寅)정묘(丁卯)무진(戊辰)기사(己巳)...을(乙), 경(庚)병자(丙子)정축(丁丑)무인(戊寅)기묘(己卯)경진(庚辰)신사(辛巳)...병(丙), 신(辛)무자(戊子)기축(己丑)경인(庚寅)신묘(辛卯)임진(壬辰)계사(癸巳)...정(丁), 임(壬)경자(庚子)신축(辛丑)임인(壬寅)계묘(癸卯)갑진(甲辰)을사(乙巳)...무(戊), 계(癸)임자(壬子)계축(癸丑)갑인(甲寅)을묘(乙卯)병진(丙辰)정사(丁巳)...데이터 출처 및 검증:.이 테이블은 데이터베이스 내 Ref_HourPillarLogic 테이블로 정규화되어 저장되어야 합니다. 시스템은 사용자의 일간이 '갑(甲)'이고 출생 시간이 '축(丑)시'라면, 쿼리를 통해 즉시 '을축(乙丑)'이라는 시주를 반환해야 하며, LLM에게 "시주를 추론하라"고 요청해서는 안 됩니다.3. 데이터베이스 스키마 설계: 단일 진실 공급원(SSOT) 구축일관성 있는 답변을 생성하기 위해서는 명리학적 지식과 사용자 데이터를 구조화된 관계형 데이터베이스(RDBMS)로 모델링해야 합니다. 스키마는 크게 사용자 및 차트 데이터(Transactional Data), 명리 지식 베이스(Reference Data), **해석 규칙(Interpretation Rules)**의 세 영역으로 구분됩니다.3.1. 사용자 및 차트 데이터 엔티티사용자의 출생 정보와 이를 기반으로 산출된 사주 원국(Natal Chart)을 저장합니다.Users 테이블: 사용자 기본 정보 (User ID, 계정 정보 등).Profiles 테이블:profile_id (PK)user_id (FK)birth_date_gregorian (DATETIME): 입력된 양력 시간.birth_date_lunar (VARCHAR): 음력 변환 값 (참조용).gender (ENUM: 'M', 'F'): 대운(大運, Luck Pillar)의 순행/역행 결정을 위해 필수.birth_city (VARCHAR), longitude (DECIMAL): 진태양시 계산용.NatalCharts 테이블: 만세력 엔진에 의해 계산된 결과값.chart_id (PK)year_stem, year_branch (FK -> Stems, Branches)month_stem, month_branchday_stem, day_branchhour_stem, hour_branchday_master_strength (ENUM: 'ExtremeWeak', 'Weak', 'Balanced', 'Strong', 'ExtremeStrong', 'Follower'): 신강/신약 판별 결과.favorable_elements (JSONB): 용신(用神) 및 희신(喜神) 데이터 (예: ``).3.2. 명리 지식 베이스 (Knowledge Graph)AI가 참조할 불변의 명리학적 속성들을 저장합니다. 이 데이터는 시스템의 '헌법'과 같아 해석의 기준점이 됩니다.Stems (천간) 테이블: 10개의 레코드 (갑~계).속성: 오행(Element), 음양(Polarity), 충(Clash) 대상, 합(Combination) 대상.Branches (지지) 테이블: 12개의 레코드 (자~해).속성: 오행, 음양, 계절(Season), 방합(Directional Combo), 삼합(Triangular Combo).hidden_stems (JSONB): 지장간(Hidden Stems) 정보는 사주의 뿌리(Root)와 격국(Structure)을 판단하는 핵심이므로 JSON 배열로 저장합니다 (예: 寅(Tiger) -> ``).SixtyJiazi (60갑자) 테이블: 60개의 간지 조합.속성: 납음오행(Na-Yin Element), 공망(Void), 12운성(12 Stages of Life), 물상론적 묘사(Image Metaphor).예시: 갑자(Jia-Zi) -> "바다 위의 나무", "시작과 창조의 기운". AI는 이 메타포를 프롬프트의 컨텍스트로 제공받아 일관된 톤앤매너로 서술할 수 있습니다.3.3. 구조화된 해석 규칙 (Interpretation Rules) 스키마단순 텍스트 덩어리가 아니라, 조건부 로직에 따라 조립 가능한 해석 모듈을 저장합니다. 이는 RAG 시스템의 검색 대상이 됩니다.[표 2] 해석 규칙 테이블(InterpretationRules) 설계안필드명 (Column)데이터 타입설명 및 예시rule_idUUID고유 식별자trigger_typeENUM규칙 발동 조건 (TEN_GOD, CLASH, COMBINATION, DM_STRENGTH)element_1VARCHAR주체 (예: Direct Officer 정관)element_2VARCHAR객체 (예: Hurting Officer 상관)condition_jsonJSONB추가 조건 (예: {"dm_strength": "WEAK", "gender": "F"})base_interpretationTEXT핵심 해석 (Fact) - "관료적인 성향과 반항심의 충돌. 직장 내 구설수 주의."advice_templateTEXT조언 템플릿 - "규칙을 준수하되 창의성을 발휘할 수 있는 독립적 업무가 유리합니다."severity_scoreINT영향력 점수 (1~10). 충돌 해결 로직에서 우선순위 산정에 사용.참조: 데이터베이스 스키마 설계 모범 사례 및 JSON 구조화.이 스키마를 통해, 시스템은 "상관견관(Hurting Officer seeing Direct Officer)"이라는 흉한 조합이 발생했을 때, 사용자의 사주 강약(condition_json)에 따라 미세 조정된 해석을 인출할 수 있습니다.4. 논리 엔진: 명리 규칙의 코드화 및 충돌 해결DB에 저장된 데이터만으로는 복잡한 상호작용을 모두 설명할 수 없습니다. '논리 엔진(Logic Engine)'은 DB와 LLM 사이에서 결정론적 연산을 수행하는 미들웨어입니다.4.1. 십신(Ten Gods) 및 육친 도출 로직십신은 일간(Day Master, 나)과 다른 글자 간의 생극(生剋) 관계 및 음양의 배합으로 결정됩니다. 이는 해석의 가장 기초가 되는 어휘입니다.알고리즘:나와 오행이 같고 음양이 같음 -> 비견 (Friend)나와 오행이 같고 음양이 다름 -> 겁재 (Rob Wealth)내가 생(生)하고 음양이 같음 -> 식신 (Eating God)내가 생(生)하고 음양이 다름 -> 상관 (Hurting Officer)내가 극(剋)하고 음양이 같음 -> 편재 (Indirect Wealth)내가 극(剋)하고 음양이 다름 -> 정재 (Direct Wealth)나를 극(剋)하고 음양이 같음 -> 편관 (Seven Killings)나를 극(剋)하고 음양이 다름 -> 정관 (Direct Officer)나를 생(生)하고 음양이 같음 -> 편인 (Indirect Resource)나를 생(生)하고 음양이 다름 -> 정인 (Direct Resource)이 로직은 10x10 매트릭스로 TenGodsLogic 테이블에 미리 매핑해두고, 런타임에 O(1) 복잡도로 조회해야 합니다. AI가 실시간으로 오행 상생상극을 따지게 하면 오류가 발생할 수 있습니다.4.2. 신강/신약(Day Master Strength) 판별 스코어링사주의 강약 판별은 해석의 방향(용신 찾기)을 결정하는 가장 중요한 분기점이나, 학파마다 견해가 갈리는 영역입니다. 일관성을 위해 정량적인 스코어링 알고리즘을 도입해야 합니다.제안된 정량적 스코어링 모델:득령(得令, Seasonality): 월지(Month Branch)가 일간을 돕거나 같은 오행인가? (가중치 40%). 예: 목(Wood) 일간이 봄(인/묘월)에 태어나면 +40점.득지(得地, Rooting): 일지, 연지, 시지에 일간의 뿌리(통근)가 있는가? 지장간의 정기, 중기, 여기를 구분하여 점수 부여 (가중치 30%).득세(得勢, Support): 천간에 인성(Resource)이나 비겁(Parallel)이 투출했는가? (가중치 20%).설기(Drain): 식상, 재성, 관성이 얼마나 강한가? (감점 요소).판정 기준: 총점 > 50점이면 '신강(Strong)', < 50점이면 '신약(Weak)'.특수 격국 처리: 점수가 극도로 낮거나(종격 가능성), 특정 오행으로 쏠린 경우 별도 플래그를 생성하여 LLM에게 "이 사주는 종격일 가능성이 높으므로 일반적인 억부용신법을 적용하지 말라"는 지시를 내려야 합니다.4.3. 상호작용의 위계 및 충돌 해결 (Conflict Resolution)사주 원국 내에는 합(Combination)과 충(Clash)이 동시에 존재할 수 있습니다. 예를 들어, 자(Rat)와 오(Horse)는 충(Clash)하지만, 옆에 축(Ox)이 있으면 자축합(Rat-Ox Combination)이 형성되어 충을 해소(탐합망충)할 수 있습니다. 이러한 우선순위 로직이 정리되지 않으면 AI는 "충돌해서 나쁘다"와 "합이 되어 좋다"는 모순된 말을 동시에 할 수 있습니다.충돌 해결 로직 (우선순위):합(合) > 충(沖): 합이 충을 해소하는지 확인합니다. 합이 성립하면 충의 부정적 해석을 억제(suppress)하는 프롬프트를 생성합니다.형(刑) > 해(害): 형살(Penalty)의 작용력이 더 강하므로 해석의 주안점을 형에 둡니다.흉신 조합 체크리스트: 특정 조합은 매우 구체적인 경고를 필요로 합니다.상관견관 (Hurting Officer + Direct Officer): "위화백단(온갖 재앙의 근원)"이라 불리며 직업적 불안정, 관재수를 암시합니다. 이 조합이 발견되면 긍정적 해석을 제한하고 "언행 주의" 조언을 강제 출력합니다.천전지충 (Fan Yin): 천간과 지지가 모두 충하는 경우, "삶의 큰 변동성"으로 해석을 고정합니다.5. LLM 통합 전략: 구조화된 출력과 프롬프트 제어견고한 DB와 논리 엔진이 준비되었다면, LLM은 '생성자'가 아니라 '번역가'로서 기능해야 합니다. 이를 위해 JSON 스키마를 통한 강제 출력 모드를 사용합니다.5.1. JSON 스키마를 활용한 통제된 생성 (Controlled Generation)Gemini API나 OpenAI의 Function Calling 기능을 활용하여, LLM의 출력을 사전에 정의된 JSON 구조로 강제합니다. 이는 파싱 에러를 방지하고 DB에 해석 결과를 재저장하기 용이하게 합니다.[코드 예시 1] 성격 분석을 위한 JSON 스키마 정의JSON{
  "type": "object",
  "properties": {
    "day_master_analysis": {
      "type": "string",
      "description": "일간(Day Master)의 오행 특성에 기반한 핵심 성격 분석. (예: 갑목의 곧은 성품)"
    },
    "chart_strength_verdict": {
      "type": "string",
      "enum": ["신강", "신약", "중화"],
      "description": "제공된 데이터에 근거한 신강/신약 판정 결과만 기재."
    },
    "key_traits": {
      "type": "array",
      "items": { "type": "string" },
      "description": "주요 성격 키워드 3~5개 추출."
    },
    "career_aptitude": {
      "type": "object",
      "properties": {
        "suitable_fields": {"type": "array", "items": {"type": "string"}},
        "work_style": {"type": "string", "description": "십신 구조(예: 식신생재)에 기반한 업무 스타일 서술."}
      }
    }
  },
  "required": ["day_master_analysis", "chart_strength_verdict", "career_aptitude"]
}
참조: 이 스키마를 사용하면 LLM은 자유롭게 소설을 쓰는 대신, chart_strength_verdict 필드에 시스템이 계산한 "신약" 값을 그대로 반영하면서, 그에 맞는 서술만을 work_style에 채워 넣게 됩니다. 이는 답변의 구조적 일관성을 100% 보장합니다.5.2. 프롬프트 엔지니어링: 페르소나 및 제약 조건 설정시스템 프롬프트(System Prompt)에는 명확한 역할과 **부정 제약(Negative Constraints)**이 포함되어야 합니다.역할 정의: "당신은 정통 자평명리학(Ziping Bazi) 전문가입니다. 제공된 차트 데이터만을 근거로 해석해야 하며, 없는 별(Star)을 지어내지 마십시오."데이터 주입 (RAG): 사용자의 질문과 함께 DB에서 추출한 InterpretationRules의 base_interpretation 텍스트를 컨텍스트로 주입합니다.Input: "사용자 사주에 '자오충(Rat-Horse Clash)'이 있음. DB 해석: '감정 기복, 심혈관 주의'."Instruction: "위의 DB 해석을 바탕으로, 사용자에게 따뜻하고 조언적인 어조로 설명하시오."파라미터 잠금: 해석의 창의성보다는 정확도가 중요하므로, Temperature 값을 0.1~0.3 수준으로 낮게 설정하여 무작위성을 최소화합니다.6. 캐싱 및 성능 최적화: 의미론적 일관성 유지사주 서비스의 특성상 동일한 생년월일을 가진 사용자가 반복적으로 질문하거나, 같은 질문을 다른 방식으로("재물운 어때요?" vs "돈 많이 벌까요?") 할 수 있습니다. 이때마다 다른 답변이 나오면 신뢰도가 하락합니다.6.1. 결정론적 캐싱 (Exact Match Caching)사용자의 생년월일시(성별 포함)는 불변의 키(Key)입니다. 이를 해시(Hash)화하여 Redis와 같은 인메모리 DB에 저장합니다.Key: hash(1990-05-05-14:30-M)Value: 1차적으로 계산된 사주 원국 데이터 및 기본 성격 분석 JSON.
이 캐시가 존재하면 연산 과정을 생략하고 즉시 결과를 반환하여 100% 동일한 기본 정보를 제공합니다.6.2. 의미론적 캐싱 (Semantic Caching)사용자의 질문 의도(Intent)를 벡터화(Vector Embedding)하여 비교합니다.사용자가 "올해 연애운?"이라고 묻고, 10분 뒤 "남자친구 생길까?"라고 물으면, 두 질문의 벡터 유사도가 높음(예: 0.9 이상)을 감지합니다.이 경우 LLM을 다시 호출하지 않고, 이전 답변을 불러와 "앞서 말씀드린 것처럼..."으로 시작하는 요약 답변을 제공하거나 동일한 맥락을 유지합니다. 이는 Pinecone이나 Milvus와 같은 벡터 DB를 통해 구현 가능합니다.7. 구현을 위한 오픈소스 리소스 및 데이터셋 구축 전략보고서 작성을 위해 조사된 자료 중, 실제 구현에 즉시 투입 가능한 핵심 리소스를 선별하였습니다.7.1. 추천 라이브러리 및 도구korean-lunar-calendar (Python): 한국천문연구원 데이터를 기반으로 하여, 중국식 달력 라이브러리가 범할 수 있는 음력/절기 오차를 방지합니다. 백엔드 연산의 핵심 모듈로 적합합니다.bazi-calculator-by-alvamind (TypeScript/Node.js): 24절기 계산, 4주 8자 산출, 십신, 12운성, 신살(Nobleman, Peach Blossom 등)까지 포괄적으로 계산해주는 라이브러리입니다. TypeScript로 작성되어 있어 데이터 타입 안정성이 높으며, 이를 포크(Fork)하여 한국 실정에 맞는 로직(예: 한국 표준시 경도 보정)만 수정하여 사용하기에 최적입니다.astral / pyswisseph (Python): 정밀한 태양/달 위치 계산이 필요할 경우(예: 절기 교체 시각의 초 단위 계산) 스위스 천문력(Swiss Ephemeris) 기반의 이 라이브러리들을 활용합니다.7.2. 데이터셋 구축 가이드LLM의 RAG 성능을 높이기 위해 다음 두 가지 데이터셋을 우선적으로 구축해야 합니다.60갑자 성격 데이터셋: 60개의 간지(갑자, 을축...) 각각에 대해 고전 텍스트와 현대적 해석을 매핑한 JSON 파일. (예: {"jia_zi": {"keywords": ["창조", "시작", "도덕"], "description": "차가운 물 위의 큰 나무로..."}}).십신 상호작용 매트릭스: 10개의 십신이 서로 만났을 때의 길흉을 정의한 N x N 매트릭스. (예: Row: 정관, Col: 상관 -> Value: 흉(Conflict), Msg: 직업 변동수).8. 결론답변의 일관성을 갖춘 사주 해석 시스템을 구축하는 것은 단순한 프롬프트 엔지니어링을 넘어선, 데이터 엔지니어링의 영역입니다. 만세력이라는 절대적 연산 엔진, 명리 규칙을 담은 관계형 데이터베이스, 그리고 해석의 논리적 모순을 사전에 차단하는 로직 엔진이 삼위일체를 이루어야 합니다.LLM은 이 견고한 구조 위에서 단지 '해석을 전달하는 화자'로서 기능해야 하며, JSON 스키마와 캐싱 전략을 통해 그 자유도를 통제함으로써 사용자는 언제, 어디서 접속하더라도 수학적으로 동일하고 논리적으로 일관된 운명 해석을 받을 수 있게 됩니다. 이는 '환각'이라는 AI의 본질적 한계를 '규칙'이라는 데이터베이스의 힘으로 극복하는 가장 효과적인 접근법입니다.부록: 핵심 참조 데이터 및 구현 로직A. 오서둔(五鼠遁) 시주 산출 로직 테이블 (Table 1 참조)B. 십신(Ten Gods) 매핑 샘플(일간 甲목 기준)甲(비견), 乙(겁재), 丙(식신), 丁(상관), 戊(편재), 己(정재), 庚(편관), 辛(정관), 壬(편인), 癸(정인).C. AI 출력 검증용 JSON 스키마(본문 5.1절 코드 블록 참조)인용 출처 표기: 본 보고서의 모든 기술적 주장, 알고리즘 로직, 라이브러리 추천은 제공된 연구 자료 에 근거하고 있습니다. 만세력 계산 공식, 십신 도출 로직 등은  등의 문헌 자료를 바탕으로 작성되었습니다.