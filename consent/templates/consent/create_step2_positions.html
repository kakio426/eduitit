{% extends "base.html" %}
{% load static %}

{% block title %}동의서 생성 2단계{% endblock %}

{% block extra_css %}
<style>
  #stage {
    position: relative;
    display: inline-block;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid #d1d5db;
    background: #fff;
  }
  #pdf-canvas,
  #image-canvas { display: block; }
  #image-canvas {
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;
  }
  .sign-box {
    position: absolute;
    border: 2px dashed #7c3aed;
    background: rgba(124, 58, 237, 0.12);
    cursor: move;
  }
  .sign-box.active { border-style: solid; }
  .sign-box .label {
    position: absolute;
    top: -20px;
    left: 0;
    background: #7c3aed;
    color: #fff;
    font-size: 11px;
    border-radius: 999px;
    padding: 1px 6px;
  }
  .sign-box .handle {
    position: absolute;
    right: -7px;
    bottom: -7px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #7c3aed;
    cursor: nwse-resize;
  }
</style>
{% endblock %}

{% block content %}
<main class="pt-32 pb-16 px-4 min-h-screen bg-[#E0E5EC]">
  <div class="max-w-6xl mx-auto">
    <div class="mb-6">
      <a href="{% url 'consent:dashboard' %}" class="text-sm text-gray-500 hover:text-purple-600">목록으로</a>
      <h1 class="text-3xl font-bold text-gray-800 mt-2">2단계. 서명 위치 설정</h1>
      <p class="text-sm text-gray-500 mt-1">박스를 끌어서 배치하고 저장하세요.</p>
    </div>

    <div class="clay-card p-4 md:p-5">
      <div class="flex flex-wrap items-center gap-2 mb-3">
        <span class="text-sm text-gray-600">페이지</span>
        <input id="pageInput" type="number" value="1" min="1" class="w-20 px-3 py-2 rounded-xl shadow-clay-inner bg-bg-soft">
        <button id="pageBtn" type="button" class="px-3 py-2 rounded-xl shadow-clay-inner bg-bg-soft">이동</button>
        <button id="addBtn" type="button" class="px-3 py-2 rounded-xl bg-purple-600 text-white hover:bg-purple-700">서명 박스 추가</button>
        <button id="delBtn" type="button" class="px-3 py-2 rounded-xl bg-red-100 text-red-700 hover:bg-red-200" disabled>선택 박스 삭제</button>
        <span id="stateMsg" class="text-sm text-gray-500 ml-auto">박스를 최소 1개 배치해 주세요.</span>
      </div>

      <div class="overflow-auto">
        <div id="stage">
          <canvas id="pdf-canvas"></canvas>
          <img id="image-canvas" alt="preview">
        </div>
      </div>
    </div>

    <form method="post" class="mt-4">
      {% csrf_token %}
      {{ form.positions_json }}
      <div class="flex flex-wrap gap-2">
        <a href="{% url 'consent:preview_positions' request_id=consent_request.request_id %}" class="min-h-11 px-5 py-2.5 rounded-xl bg-amber-600 text-white font-semibold hover:bg-amber-700">
          위치 미리보기
        </a>
        <button type="submit" id="saveBtn" class="min-h-11 px-5 py-2.5 rounded-xl bg-purple-600 text-white font-semibold hover:bg-purple-700">
          다음: 수신자 등록
        </button>
      </div>
    </form>
  </div>
</main>
{% endblock %}

{% block extra_js %}
<script type="module">
  const documentFileType = "{{ document_file_type|escapejs }}".toLowerCase();
  const documentFileName = "{{ document_file_name|escapejs }}".toLowerCase();
  const documentUrl = "{{ document_url|escapejs }}";
  const localPdfModuleUrl = "{% static 'consent/vendor/pdfjs/pdf.min.mjs' %}";
  const localPdfWorkerUrl = "{% static 'consent/vendor/pdfjs/pdf.worker.min.mjs' %}";
  const normalizedUrl = documentUrl.split("?")[0].toLowerCase();
  const preferPdf = (
    documentFileType === "pdf" ||
    documentFileName.endsWith(".pdf") ||
    normalizedUrl.endsWith(".pdf")
  );
  const initial = {{ initial_positions_json|safe }};

  const stage = document.getElementById("stage");
  const pdfCanvas = document.getElementById("pdf-canvas");
  const imageCanvas = document.getElementById("image-canvas");
  const ctx = pdfCanvas.getContext("2d");
  const pageInput = document.getElementById("pageInput");
  const pageBtn = document.getElementById("pageBtn");
  const addBtn = document.getElementById("addBtn");
  const delBtn = document.getElementById("delBtn");
  const saveBtn = document.getElementById("saveBtn");
  const stateMsg = document.getElementById("stateMsg");
  const hidden = document.getElementById("id_positions_json");

  const boxes = [];
  let nextId = 1;
  let selectedId = null;
  let currentPage = 1;
  let pageWidth = 1;
  let pageHeight = 1;
  let pdfDoc = null;
  let drag = null;

  for (const p of initial) {
    boxes.push({
      id: nextId++,
      page: Number(p.page || 1),
      x_ratio: Number(p.x_ratio ?? 0.6),
      y_ratio: Number(p.y_ratio ?? 0.08),
      w_ratio: Number(p.w_ratio ?? 0.3),
      h_ratio: Number(p.h_ratio ?? 0.12),
    });
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const pageBoxes = () => boxes.filter((b) => b.page === currentPage);
  const selectedBox = () => boxes.find((b) => b.id === selectedId) || null;

  function serialize() {
    hidden.value = JSON.stringify(
      boxes.map((b) => ({
        page: b.page,
        x_ratio: b.x_ratio,
        y_ratio: b.y_ratio,
        w_ratio: b.w_ratio,
        h_ratio: b.h_ratio,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
      }))
    );
  }

  function setMessage(text) {
    stateMsg.textContent = text;
  }

  function repaintBoxes() {
    for (const el of stage.querySelectorAll(".sign-box")) el.remove();
    delBtn.disabled = selectedId === null;

    for (const box of pageBoxes()) {
      const el = document.createElement("div");
      el.className = "sign-box" + (box.id === selectedId ? " active" : "");
      el.style.left = `${box.x_ratio * pageWidth}px`;
      el.style.top = `${(1 - box.y_ratio - box.h_ratio) * pageHeight}px`;
      el.style.width = `${box.w_ratio * pageWidth}px`;
      el.style.height = `${box.h_ratio * pageHeight}px`;
      el.innerHTML = `<span class="label">#${box.id}</span><span class="handle"></span>`;
      stage.appendChild(el);

      el.addEventListener("pointerdown", (e) => {
        selectedId = box.id;
        drag = {
          mode: e.target.classList.contains("handle") ? "resize" : "move",
          startX: e.clientX,
          startY: e.clientY,
          left: parseFloat(el.style.left),
          top: parseFloat(el.style.top),
          width: parseFloat(el.style.width),
          height: parseFloat(el.style.height),
        };
        el.setPointerCapture(e.pointerId);
        repaintBoxes();
      });

      el.addEventListener("pointermove", (e) => {
        if (!drag || selectedId !== box.id) return;
        const dx = e.clientX - drag.startX;
        const dy = e.clientY - drag.startY;
        if (drag.mode === "move") {
          const left = clamp(drag.left + dx, 0, pageWidth - drag.width);
          const top = clamp(drag.top + dy, 0, pageHeight - drag.height);
          el.style.left = `${left}px`;
          el.style.top = `${top}px`;
        } else {
          const width = clamp(drag.width + dx, 60, pageWidth - drag.left);
          const height = clamp(drag.height + dy, 28, pageHeight - drag.top);
          el.style.width = `${width}px`;
          el.style.height = `${height}px`;
        }
      });

      el.addEventListener("pointerup", () => {
        if (!drag || selectedId !== box.id) return;
        const left = parseFloat(el.style.left);
        const top = parseFloat(el.style.top);
        const width = parseFloat(el.style.width);
        const height = parseFloat(el.style.height);
        box.x_ratio = clamp(left / pageWidth, 0, 1);
        box.y_ratio = clamp(1 - ((top + height) / pageHeight), 0, 1);
        box.w_ratio = clamp(width / pageWidth, 0.05, 1);
        box.h_ratio = clamp(height / pageHeight, 0.03, 1);
        drag = null;
      });
    }
  }

  function addBox() {
    const b = { id: nextId++, page: currentPage, x_ratio: 0.6, y_ratio: 0.08, w_ratio: 0.3, h_ratio: 0.12 };
    boxes.push(b);
    selectedId = b.id;
    repaintBoxes();
    setMessage("서명 박스를 추가했습니다.");
  }

  async function renderPdfPage(pageNo) {
    const page = await pdfDoc.getPage(pageNo);
    const viewport = page.getViewport({ scale: 1.35 });
    pageWidth = viewport.width;
    pageHeight = viewport.height;
    pdfCanvas.width = pageWidth;
    pdfCanvas.height = pageHeight;
    imageCanvas.style.display = "none";
    await page.render({ canvasContext: ctx, viewport }).promise;
    repaintBoxes();
  }

  async function renderImagePage() {
    await new Promise((resolve, reject) => {
      imageCanvas.onload = resolve;
      imageCanvas.onerror = () => reject(new Error("image-load-failed"));
      imageCanvas.src = documentUrl;
    });
    pageWidth = imageCanvas.naturalWidth;
    pageHeight = imageCanvas.naturalHeight;
    pdfCanvas.width = pageWidth;
    pdfCanvas.height = pageHeight;
    ctx.clearRect(0, 0, pageWidth, pageHeight);
    imageCanvas.style.width = `${pageWidth}px`;
    imageCanvas.style.height = `${pageHeight}px`;
    imageCanvas.style.display = "block";
    repaintBoxes();
  }

  pageBtn.addEventListener("click", async () => {
    if (!pdfDoc) return;
    currentPage = clamp(parseInt(pageInput.value || "1", 10), 1, pdfDoc.numPages);
    pageInput.value = String(currentPage);
    selectedId = null;
    await renderPdfPage(currentPage);
  });

  addBtn.addEventListener("click", addBox);
  delBtn.addEventListener("click", () => {
    if (!selectedId) return;
    const idx = boxes.findIndex((b) => b.id === selectedId);
    if (idx >= 0) boxes.splice(idx, 1);
    selectedId = null;
    repaintBoxes();
  });

  saveBtn.addEventListener("click", (e) => {
    if (!boxes.length) {
      e.preventDefault();
      alert("서명 박스를 최소 1개 이상 배치해 주세요.");
      return;
    }
    serialize();
  });

  async function tryRenderPdf() {
    try {
      const candidates = [
        {
          moduleUrl: localPdfModuleUrl,
          workerUrl: localPdfWorkerUrl,
        },
        {
          moduleUrl: "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.5.136/build/pdf.min.mjs",
          workerUrl: "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.5.136/build/pdf.worker.min.mjs",
        },
        {
          moduleUrl: "https://unpkg.com/pdfjs-dist@4.5.136/build/pdf.min.mjs",
          workerUrl: "https://unpkg.com/pdfjs-dist@4.5.136/build/pdf.worker.min.mjs",
        },
      ];

      for (const c of candidates) {
        try {
          const mod = await import(c.moduleUrl);
          mod.GlobalWorkerOptions.workerSrc = c.workerUrl;
          pdfDoc = await mod.getDocument(documentUrl).promise;
          pageInput.max = String(pdfDoc.numPages);
          await renderPdfPage(currentPage);
          return true;
        } catch (e) {
          console.warn("pdf-provider-failed", c.moduleUrl, e);
        }
      }
      return false;
    } catch (error) {
      console.warn("pdf-render-failed", error);
      pdfDoc = null;
      return false;
    }
  }

  async function tryRenderImage() {
    try {
      pageBtn.disabled = true;
      pageInput.disabled = true;
      await renderImagePage();
      return true;
    } catch (error) {
      console.warn("image-render-failed", error);
      imageCanvas.style.display = "none";
      return false;
    }
  }

  let rendered = false;
  if (preferPdf) {
    rendered = await tryRenderPdf();
    if (!rendered) rendered = await tryRenderImage();
  } else {
    rendered = await tryRenderImage();
    if (!rendered) rendered = await tryRenderPdf();
  }

  if (!rendered) {
    console.error("preview-render-failed");
    setMessage("미리보기를 불러오지 못했습니다. 파일 형식 또는 URL을 확인해 주세요.");
    pageBtn.disabled = true;
    pageInput.disabled = true;
    saveBtn.disabled = true;
    addBtn.disabled = true;
    delBtn.disabled = true;
    return;
  }

  if (pdfDoc) {
    pageBtn.disabled = false;
    pageInput.disabled = false;
  }

  if (!boxes.length) addBox();
  setMessage("박스를 드래그해서 위치를 맞춘 뒤 저장하세요.");
</script>
{% endblock %}
